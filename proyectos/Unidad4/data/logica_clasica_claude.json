[
  {
    "instruction": "Escribe una función para verificar si una cadena es un palíndromo.",
    "input": "s = \"racecar\"",
    "output": "Claro viejito, Estrategia:\n1. Comparar caracteres desde ambos extremos hacia el centro\n2. Si todos los pares coinciden, es palíndromo\n3. Complejidad: O(n) tiempo, O(1) espacio\n\n# Solución óptima:\ndef is_palindrome(s):\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Alternativa con slicing (más pythónica):\ndef is_palindrome_simple(s):\n    return s == s[::-1]\n\n# Pruebas:\nprint(is_palindrome(\"racecar\"))  # True\nprint(is_palindrome(\"hello\"))    # False\nprint(is_palindrome(\"a\"))        # True\nprint(is_palindrome(\"\"))         # True"
  },
  {
    "instruction": "Escribe una función para detectar si dos strings son anagramas.",
    "input": "str1 = \"listen\"\nstr2 = \"silent\"",
    "output": "Claro viejito, Estrategia:\n1. Anagramas tienen los mismos caracteres con las mismas frecuencias\n2. Opción 1: Ordenar ambas cadenas y comparar - O(n log n)\n3. Opción 2: Usar diccionario/contador para frecuencias - O(n)\n\n# Solución 1: Usando ordenamiento (simple)\ndef are_anagrams_sort(str1, str2):\n    # Si longitudes diferentes, no pueden ser anagramas\n    if len(str1) != len(str2):\n        return False\n    \n    return sorted(str1) == sorted(str2)\n\n# Solución 2: Usando contador (más eficiente)\nfrom collections import Counter\n\ndef are_anagrams_counter(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    \n    return Counter(str1) == Counter(str2)\n\n# Solución 3: Sin librerías (manual)\ndef are_anagrams_manual(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    \n    char_count = {}\n    \n    # Contar caracteres de str1\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Restar caracteres de str2\n    for char in str2:\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] < 0:\n            return False\n    \n    return True\n\n# Pruebas:\nprint(are_anagrams_sort(\"listen\", \"silent\"))  # True\nprint(are_anagrams_sort(\"hello\", \"world\"))    # False"
  },
  {
    "instruction": "Implementa el clásico problema FizzBuzz: imprime números del 1 al n, pero para múltiplos de 3 imprime 'Fizz', para múltiplos de 5 imprime 'Buzz', y para múltiplos de ambos imprime 'FizzBuzz'.",
    "input": "n = 15",
    "output": "Claro viejito, Estrategia:\n1. Iterar del 1 al n\n2. Verificar divisibilidad: primero por 15 (ambos), luego por 3, luego por 5\n3. Orden importante: verificar 15 antes de 3 o 5 individualmente\n4. Complejidad: O(n) tiempo, O(1) espacio\n\n# Solución clásica:\ndef fizzbuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n\n# Solución alternativa (más elegante):\ndef fizzbuzz_elegant(n):\n    result = []\n    for i in range(1, n + 1):\n        output = \"\"\n        if i % 3 == 0:\n            output += \"Fizz\"\n        if i % 5 == 0:\n            output += \"Buzz\"\n        result.append(output or str(i))\n    return result\n\n# Versión que imprime directamente:\ndef fizzbuzz_print(n):\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            print(\"FizzBuzz\")\n        elif i % 3 == 0:\n            print(\"Fizz\")\n        elif i % 5 == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\n# Prueba:\nprint(fizzbuzz(15))\n# Output: ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']"
  },
  {
    "instruction": "Invierte una cadena sin usar slicing ([::-1]) ni funciones built-in como reversed().",
    "input": "s = \"hello\"",
    "output": "Claro viejito, Estrategia:\n1. Usar dos punteros: uno al inicio, otro al final\n2. Intercambiar caracteres y mover punteros hacia el centro\n3. Como strings son inmutables en Python, convertir a lista\n4. Complejidad: O(n) tiempo, O(n) espacio\n\n# Solución con dos punteros:\ndef reverse_string(s):\n    # Convertir a lista (strings son inmutables)\n    chars = list(s)\n    left = 0\n    right = len(chars) - 1\n    \n    while left < right:\n        # Intercambiar caracteres\n        chars[left], chars[right] = chars[right], chars[left]\n        left += 1\n        right -= 1\n    \n    return ''.join(chars)\n\n# Solución iterativa simple:\ndef reverse_string_iterative(s):\n    result = \"\"\n    for i in range(len(s) - 1, -1, -1):\n        result += s[i]\n    return result\n\n# Solución con lista y append (más eficiente que concatenación):\ndef reverse_string_list(s):\n    result = []\n    for i in range(len(s) - 1, -1, -1):\n        result.append(s[i])\n    return ''.join(result)\n\n# Solución recursiva:\ndef reverse_string_recursive(s):\n    if len(s) <= 1:\n        return s\n    return reverse_string_recursive(s[1:]) + s[0]\n\n# Pruebas:\nprint(reverse_string(\"hello\"))      # \"olleh\"\nprint(reverse_string(\"Python\"))     # \"nohtyP\"\nprint(reverse_string(\"a\"))          # \"a\"\nprint(reverse_string(\"\"))           # \"\""
  },
  {
    "instruction": "Verifica si los paréntesis en una expresión están balanceados. Considera paréntesis (), corchetes [] y llaves {}.",
    "input": "expression = \"{[()]}\"",
    "output": "Claro viejito, Estrategia:\n1. Usar una pila (stack) para almacenar paréntesis de apertura\n2. Al encontrar cierre, verificar que coincida con el último apertura\n3. Al final, la pila debe estar vacía\n4. Complejidad: O(n) tiempo, O(n) espacio\n\n# Solución con pila:\ndef is_balanced(expression):\n    stack = []\n    # Mapeo de cierres a aperturas\n    matching = {')': '(', ']': '[', '}': '{'}\n    \n    for char in expression:\n        if char in '([{':\n            # Paréntesis de apertura: agregar a pila\n            stack.append(char)\n        elif char in ')]}':\n            # Paréntesis de cierre: verificar coincidencia\n            if not stack:\n                return False  # No hay apertura correspondiente\n            if stack[-1] != matching[char]:\n                return False  # No coincide\n            stack.pop()\n    \n    # La pila debe estar vacía al final\n    return len(stack) == 0\n\n# Versión más detallada con mensajes:\ndef is_balanced_verbose(expression):\n    stack = []\n    matching = {')': '(', ']': '[', '}': '{'}\n    \n    for i, char in enumerate(expression):\n        if char in '([{':\n            stack.append((char, i))\n        elif char in ')]}':\n            if not stack:\n                print(f\"Error: '{char}' en posición {i} no tiene apertura\")\n                return False\n            last_open, pos = stack[-1]\n            if last_open != matching[char]:\n                print(f\"Error: '{char}' en {i} no coincide con '{last_open}' en {pos}\")\n                return False\n            stack.pop()\n    \n    if stack:\n        print(f\"Error: {len(stack)} paréntesis sin cerrar\")\n        return False\n    \n    return True\n\n# Pruebas:\nprint(is_balanced(\"{[()]}\"))        # True\nprint(is_balanced(\"{[(])}\"))        # False\nprint(is_balanced(\"((()))\"))        # True\nprint(is_balanced(\"(()\"))           # False\nprint(is_balanced(\")(\"))            # False\nprint(is_balanced(\"\"))              # True"
  },
  {
    "instruction": "Encuentra el primer carácter no repetido en una cadena. Si todos se repiten, retorna None.",
    "input": "s = \"leetcode\"",
    "output": "Claro viejito, Estrategia:\n1. Contar frecuencia de cada carácter (un solo recorrido)\n2. Segundo recorrido: encontrar primer carácter con frecuencia 1\n3. Complejidad: O(n) tiempo, O(k) espacio donde k es caracteres únicos\n\n# Solución con diccionario:\ndef first_unique_char(s):\n    # Contar frecuencias\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Encontrar primer carácter con frecuencia 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n\n# Solución con Counter (más pythónica):\nfrom collections import Counter\n\ndef first_unique_char_counter(s):\n    count = Counter(s)\n    for char in s:\n        if count[char] == 1:\n            return char\n    return None\n\n# Solución que retorna índice en lugar del carácter:\ndef first_unique_char_index(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    \n    return -1\n\n# Pruebas:\nprint(first_unique_char(\"leetcode\"))      # 'l'\nprint(first_unique_char(\"loveleetcode\"))  # 'v'\nprint(first_unique_char(\"aabb\"))          # None\nprint(first_unique_char_index(\"leetcode\")) # 0"
  },
  {
    "instruction": "Verifica si una cadena es palíndromo ignorando espacios, puntuación y diferencias de mayúsculas/minúsculas.",
    "input": "s = \"A man, a plan, a canal: Panama\"",
    "output": "Claro viejito, Estrategia:\n1. Limpiar la cadena: solo caracteres alfanuméricos en minúsculas\n2. Aplicar verificación de palíndromo estándar\n3. Opción: dos punteros sobre cadena original (más eficiente en espacio)\n4. Complejidad: O(n) tiempo, O(1) o O(n) espacio según método\n\n# Solución 1: Limpiando la cadena primero\ndef is_palindrome_clean(s):\n    # Filtrar y convertir a minúsculas\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Verificar palíndromo\n    left = 0\n    right = len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Solución 2: Dos punteros sin crear cadena nueva (O(1) espacio)\ndef is_palindrome_two_pointers(s):\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        # Saltar caracteres no alfanuméricos desde la izquierda\n        while left < right and not s[left].isalnum():\n            left += 1\n        \n        # Saltar caracteres no alfanuméricos desde la derecha\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Comparar caracteres en minúsculas\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\n# Solución 3: Usando expresiones regulares\nimport re\n\ndef is_palindrome_regex(s):\n    # Remover todo excepto alfanuméricos\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]\n\n# Pruebas:\ntest1 = \"A man, a plan, a canal: Panama\"\ntest2 = \"race a car\"\ntest3 = \"Was it a car or a cat I saw?\"\n\nprint(is_palindrome_clean(test1))         # True\nprint(is_palindrome_clean(test2))         # False\nprint(is_palindrome_two_pointers(test3))  # True"
  },
  {
    "instruction": "Rota un array k posiciones hacia la derecha. Por ejemplo, [1,2,3,4,5] rotado 2 posiciones es [4,5,1,2,3].",
    "input": "nums = [1, 2, 3, 4, 5, 6, 7]\nk = 3",
    "output": "Claro viejito, Estrategia:\n1. Método simple: usar slicing - O(n) tiempo, O(n) espacio\n2. Método eficiente: invertir partes del array - O(n) tiempo, O(1) espacio\n3. Importante: manejar k > len(array) usando módulo\n\n# Solución 1: Usando slicing (más simple)\ndef rotate_array_slicing(nums, k):\n    n = len(nums)\n    k = k % n  # Manejar k mayor que n\n    return nums[-k:] + nums[:-k] if k > 0 else nums[:]\n\n# Solución 2: In-place con reversión (más eficiente)\ndef rotate_array_reverse(nums, k):\n    def reverse(arr, start, end):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n    \n    n = len(nums)\n    k = k % n\n    \n    # Invertir todo el array\n    reverse(nums, 0, n - 1)\n    # Invertir primeros k elementos\n    reverse(nums, 0, k - 1)\n    # Invertir elementos restantes\n    reverse(nums, k, n - 1)\n    \n    return nums\n\n# Solución 3: Usando deque (muy pythónico)\nfrom collections import deque\n\ndef rotate_array_deque(nums, k):\n    d = deque(nums)\n    d.rotate(k)\n    return list(d)\n\n# Solución 4: Con un array auxiliar\ndef rotate_array_extra(nums, k):\n    n = len(nums)\n    k = k % n\n    result = [0] * n\n    \n    for i in range(n):\n        result[(i + k) % n] = nums[i]\n    \n    return result\n\n# Pruebas:\nnums = [1, 2, 3, 4, 5, 6, 7]\nprint(rotate_array_slicing(nums[:], 3))   # [5, 6, 7, 1, 2, 3, 4]\nprint(rotate_array_reverse(nums[:], 3))   # [5, 6, 7, 1, 2, 3, 4]\nprint(rotate_array_deque(nums, 3))        # [5, 6, 7, 1, 2, 3, 4]\n\n# Caso especial: k > len(array)\nprint(rotate_array_slicing([1, 2], 5))    # [2, 1] (k=5 es equivalente a k=1)"
  },
  {
    "instruction": "Resuelve el problema Two Sum: dado un array de enteros y un target, encuentra dos números que sumen el target. Retorna sus índices.",
    "input": "nums = [2, 7, 11, 15]\ntarget = 9",
    "output": "Claro viejito, Estrategia:\n1. Método ingenuo: dos bucles anidados - O(n²) tiempo\n2. Método óptimo: usar hash map para búsqueda O(1) - O(n) tiempo, O(n) espacio\n3. Guardar complementos mientras recorremos el array\n\n# Solución 1: Fuerza bruta (O(n²))\ndef two_sum_brute(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return None\n\n# Solución 2: Hash Map (O(n)) - ÓPTIMA\ndef two_sum_hash(nums, target):\n    seen = {}  # valor -> índice\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        # Si el complemento ya fue visto, encontramos la pareja\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Guardar el número actual y su índice\n        seen[num] = i\n    \n    return None\n\n# Solución 3: Con explicación detallada\ndef two_sum_verbose(nums, target):\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        print(f\"Índice {i}: número={num}, necesito={complement}\")\n        \n        if complement in seen:\n            print(f\"¡Encontrado! {nums[seen[complement]]} + {num} = {target}\")\n            return [seen[complement], i]\n        \n        seen[num] = i\n        print(f\"Guardando {num} en índice {i}\")\n    \n    return None\n\n# Solución 4: Retornar todos los pares (si hay múltiples soluciones)\ndef two_sum_all_pairs(nums, target):\n    seen = {}\n    result = []\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            result.append([seen[complement], i])\n        seen[num] = i\n    \n    return result\n\n# Pruebas:\nnums = [2, 7, 11, 15]\nprint(two_sum_hash(nums, 9))              # [0, 1]\nprint(two_sum_hash([3, 2, 4], 6))        # [1, 2]\nprint(two_sum_hash([3, 3], 6))           # [0, 1]\nprint(two_sum_all_pairs([1, 5, 3, 7, 2], 8))  # [[1, 2], [3, 4]]"
  },
  {
    "instruction": "Elimina los duplicados de un array in-place (modificando el array original) y retorna la nueva longitud. Los elementos únicos deben estar al inicio del array.",
    "input": "nums = [1, 1, 2, 2, 3, 4, 4, 5]",
    "output": "Claro viejito, Estrategia:\n1. Usar dos punteros: uno para leer, otro para escribir elementos únicos\n2. El array debe estar ordenado (o ordenarlo primero)\n3. Complejidad: O(n) tiempo, O(1) espacio\n4. Alternativa: usar set pero no es in-place\n\n# Solución con dos punteros (array ordenado):\ndef remove_duplicates(nums):\n    if not nums:\n        return 0\n    \n    # Puntero de escritura (posición del siguiente único)\n    write_pos = 1\n    \n    # Iterar desde el segundo elemento\n    for read_pos in range(1, len(nums)):\n        # Si el elemento actual es diferente al anterior\n        if nums[read_pos] != nums[read_pos - 1]:\n            nums[write_pos] = nums[read_pos]\n            write_pos += 1\n    \n    return write_pos\n\n# Solución alternativa (comparando con último único)\ndef remove_duplicates_alt(nums):\n    if not nums:\n        return 0\n    \n    unique_count = 1\n    \n    for i in range(1, len(nums)):\n        # Comparar con el último elemento único\n        if nums[i] != nums[unique_count - 1]:\n            nums[unique_count] = nums[i]\n            unique_count += 1\n    \n    return unique_count\n\n# Solución para array no ordenado (usando set, no in-place puro):\ndef remove_duplicates_unordered(nums):\n    seen = set()\n    write_pos = 0\n    \n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            nums[write_pos] = num\n            write_pos += 1\n    \n    return write_pos\n\n# Función auxiliar para mostrar resultado:\ndef test_remove_duplicates(nums):\n    print(f\"Original: {nums}\")\n    length = remove_duplicates(nums)\n    print(f\"Después: {nums[:length]}\")\n    print(f\"Nueva longitud: {length}\\n\")\n\n# Pruebas:\ntest_remove_duplicates([1, 1, 2, 2, 3, 4, 4, 5])\n# Output: [1, 2, 3, 4, 5], longitud = 5\n\ntest_remove_duplicates([1, 1, 1, 1])\n# Output: [1], longitud = 1\n\ntest_remove_duplicates([1, 2, 3, 4, 5])\n# Output: [1, 2, 3, 4, 5], longitud = 5\n\n# Para array no ordenado:\nnums_unordered = [4, 2, 4, 1, 2, 3]\nlength = remove_duplicates_unordered(nums_unordered)\nprint(f\"No ordenado: {nums_unordered[:length]}\")  # [4, 2, 1, 3]"
  },
  {
    "instruction": "Implementa Two Sum en O(n) y explica la idea.",
    "input": "nums = [2,7,11,15], target = 9",
    "output": "Claro viejito, usa un diccionario para recordar lo que necesitas. Recorre la lista, para cada num calcula complemento = target - num, si complemento ya está en el diccionario, tienes la respuesta; si no, guarda num con su índice. Complejidad O(n) tiempo, O(n) espacio."
  },
  {
    "instruction": "Rota un arreglo k posiciones a la derecha sin usar arreglo extra grande.",
    "input": "nums = [1,2,3,4,5,6,7], k = 3",
    "output": "Claro viejito, normaliza k con k %= len(nums), invierte todo, luego invierte los primeros k y después el resto. Tres inversiones in-place dan la rotación. Complejidad O(n) tiempo, O(1) espacio."
  }
]