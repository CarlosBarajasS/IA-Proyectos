[
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO SumaMatriz\nVARIABLES\n    matriz[3][3] : ENTERO\n    suma : ENTERO\n    i, j : ENTERO\nINICIO\n    suma <- 0\n    PARA i DE 1 A 3 HACER\n        PARA j DE 1 A 3 HACER\n            suma <- suma + matriz[i][j]\n        FIN_PARA\n    FIN_PARA\n    ESCRIBIR suma\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\nmatriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Ejemplo de inicialización\nsuma = 0\n\nfor i in range(3):\n    for j in range(3):\n        suma = suma + matriz[i][j]\n\nprint(suma)\n\nDiferencias sintácticas:\n1. Python usa 'range(3)' que genera índices 0, 1, 2 (no 1, 2, 3 como el pseudocódigo).\n2. La flecha de asignación '<-' se convierte en '='.\n3. Los bloques se definen por indentación, no por palabras clave FIN_PARA.\n4. 'ESCRIBIR' se convierte en 'print()'.\n5. Python accede a matrices con [i][j] igual que el pseudocódigo, pero los índices comienzan en 0."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO NumeroMayor\nVARIABLES\n    a, b, c, mayor : ENTERO\nINICIO\n    LEER a, b, c\n    SI (a > b) Y (a > c) ENTONCES\n        mayor <- a\n    SINO SI (b > a) Y (b > c) ENTONCES\n        mayor <- b\n    SINO\n        mayor <- c\n    FIN_SI\n    ESCRIBIR \"El mayor es: \", mayor\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\na = int(input(\"Ingrese a: \"))\nb = int(input(\"Ingrese b: \"))\nc = int(input(\"Ingrese c: \"))\n\nif (a > b) and (a > c):\n    mayor = a\nelif (b > a) and (b > c):\n    mayor = b\nelse:\n    mayor = c\n\nprint(\"El mayor es:\", mayor)\n\nDiferencias sintácticas:\n1. 'LEER' se convierte en 'input()' envuelto en 'int()' para convertir a entero.\n2. 'SI' se convierte en 'if', 'SINO SI' en 'elif', y 'SINO' en 'else'.\n3. 'Y' lógico se escribe como 'and' en Python (también existe 'or' para O, y 'not' para NO).\n4. Los bloques condicionales usan ':' al final y se definen por indentación.\n5. No se necesita 'FIN_SI' explícito, la indentación marca el fin del bloque."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO AlgoritmoEuclides\nVARIABLES\n    a, b, temp : ENTERO\nINICIO\n    LEER a, b\n    MIENTRAS b != 0 HACER\n        temp <- b\n        b <- a MOD b\n        a <- temp\n    FIN_MIENTRAS\n    ESCRIBIR \"MCD es: \", a\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\na = int(input(\"Ingrese a: \"))\nb = int(input(\"Ingrese b: \"))\n\nwhile b != 0:\n    temp = b\n    b = a % b\n    a = temp\n\nprint(\"MCD es:\", a)\n\nDiferencias sintácticas:\n1. 'MIENTRAS' se convierte en 'while' seguido de ':' y el bloque indentado.\n2. 'MOD' (módulo) en Python se representa con el operador '%'.\n3. '!=' es el operador de desigualdad tanto en pseudocódigo como en Python.\n4. No se necesita 'FIN_MIENTRAS', el fin del bucle se determina por la indentación.\n5. Este es el algoritmo de Euclides clásico para encontrar el Máximo Común Divisor."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO BusquedaElemento\nVARIABLES\n    arreglo[10] : ENTERO\n    buscar, i : ENTERO\n    encontrado : BOOLEANO\nINICIO\n    encontrado <- FALSO\n    LEER buscar\n    PARA i DE 1 A 10 HACER\n        SI arreglo[i] = buscar ENTONCES\n            encontrado <- VERDADERO\n            ROMPER\n        FIN_SI\n    FIN_PARA\n    SI encontrado ENTONCES\n        ESCRIBIR \"Elemento encontrado\"\n    SINO\n        ESCRIBIR \"Elemento no encontrado\"\n    FIN_SI\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\narreglo = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]  # Ejemplo\nencontrado = False\nbuscar = int(input(\"Ingrese número a buscar: \"))\n\nfor i in range(10):\n    if arreglo[i] == buscar:\n        encontrado = True\n        break\n\nif encontrado:\n    print(\"Elemento encontrado\")\nelse:\n    print(\"Elemento no encontrado\")\n\nDiferencias sintácticas:\n1. 'BOOLEANO' se maneja con 'True' y 'False' (capitalizados) en Python.\n2. 'FALSO' y 'VERDADERO' se convierten en 'False' y 'True'.\n3. 'ROMPER' se convierte en 'break' para salir del bucle anticipadamente.\n4. El operador de igualdad en Python es '==' (un solo '=' es asignación).\n5. 'range(10)' genera índices 0-9, por lo que arreglo[i] accede correctamente en Python."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO TablaMultiplicar\nVARIABLES\n    numero, i, resultado : ENTERO\nINICIO\n    LEER numero\n    PARA i DE 1 A 10 HACER\n        resultado <- numero * i\n        ESCRIBIR numero, \" x \", i, \" = \", resultado\n    FIN_PARA\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\nnumero = int(input(\"Ingrese número: \"))\n\nfor i in range(1, 11):\n    resultado = numero * i\n    print(f\"{numero} x {i} = {resultado}\")\n\nDiferencias sintácticas:\n1. 'range(1, 11)' genera números del 1 al 10 (el límite superior es exclusivo).\n2. Para iterar de 1 a N en pseudocódigo, usamos 'range(1, N+1)' en Python.\n3. Usé f-strings (f\"...\") para formateo de cadenas, más moderno que concatenación.\n4. Alternativa clásica: print(numero, \"x\", i, \"=\", resultado) con comas.\n5. El operador '*' para multiplicación es idéntico en ambos lenguajes."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO FibonacciIterativo\nVARIABLES\n    n, i, a, b, temp : ENTERO\nINICIO\n    LEER n\n    a <- 0\n    b <- 1\n    ESCRIBIR a\n    ESCRIBIR b\n    PARA i DE 3 A n HACER\n        temp <- a + b\n        a <- b\n        b <- temp\n        ESCRIBIR temp\n    FIN_PARA\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\nn = int(input(\"Ingrese cantidad de términos: \"))\na = 0\nb = 1\n\nprint(a)\nprint(b)\n\nfor i in range(3, n + 1):\n    temp = a + b\n    a = b\n    b = temp\n    print(temp)\n\nDiferencias sintácticas:\n1. 'range(3, n + 1)' itera desde 3 hasta n inclusive (simulando 'DE 3 A n').\n2. En Python, múltiples asignaciones se pueden hacer en una línea: 'a, b = b, a + b'.\n3. Esta versión muestra la forma literal equivalente al pseudocódigo.\n4. Alternativa pythónica: for _ in range(n-2): temp = a + b; a, b = b, temp; print(temp)\n5. Los primeros dos términos (0, 1) se imprimen antes del bucle."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO OrdenamientoBurbuja\nVARIABLES\n    arreglo[5] : ENTERO\n    i, j, temp : ENTERO\nINICIO\n    PARA i DE 1 A 4 HACER\n        PARA j DE 1 A (5 - i) HACER\n            SI arreglo[j] > arreglo[j+1] ENTONCES\n                temp <- arreglo[j]\n                arreglo[j] <- arreglo[j+1]\n                arreglo[j+1] <- temp\n            FIN_SI\n        FIN_PARA\n    FIN_PARA\n    ESCRIBIR arreglo\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\narreglo = [64, 34, 25, 12, 22]  # Ejemplo de inicialización\n\nfor i in range(4):\n    for j in range(5 - i - 1):\n        if arreglo[j] > arreglo[j + 1]:\n            temp = arreglo[j]\n            arreglo[j] = arreglo[j + 1]\n            arreglo[j + 1] = temp\n\nprint(arreglo)\n\nDiferencias sintácticas:\n1. Ajuste crítico: 'range(5 - i - 1)' porque range genera índices base 0 y necesitamos evitar arreglo[j+1] fuera de límites.\n2. En pseudocódigo 'DE 1 A (5-i)' incluye el límite, en Python range(5-i-1) genera 0 hasta 5-i-2.\n3. Python permite intercambio elegante: 'arreglo[j], arreglo[j+1] = arreglo[j+1], arreglo[j]' sin variable temporal.\n4. Esta es la implementación de Bubble Sort con bucles anidados.\n5. print() puede mostrar listas directamente con formato [a, b, c, ...]."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "FUNCIÓN Potencia(base, exponente : ENTERO) : ENTERO\nVARIABLES\n    resultado, i : ENTERO\nINICIO\n    resultado <- 1\n    PARA i DE 1 A exponente HACER\n        resultado <- resultado * base\n    FIN_PARA\n    RETORNAR resultado\nFIN_FUNCIÓN",
    "output": "Claro viejito, # Código Python equivalente:\ndef potencia(base, exponente):\n    resultado = 1\n    for i in range(1, exponente + 1):\n        resultado = resultado * base\n    return resultado\n\n# Ejemplo de uso:\nprint(potencia(2, 3))  # Output: 8\n\nDiferencias sintácticas:\n1. 'FUNCIÓN' se convierte en 'def nombre_funcion(parámetros):'.\n2. Python no requiere declaración explícita de tipos en los parámetros.\n3. 'RETORNAR' se convierte en 'return'.\n4. 'FIN_FUNCIÓN' no existe, el fin de la función se marca por cambio de indentación.\n5. Python tiene operador '**' para potencias: base ** exponente sería más directo.\n6. 'range(1, exponente + 1)' itera de 1 a exponente inclusive."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO ContarParesImpares\nVARIABLES\n    numeros[10] : ENTERO\n    i, pares, impares : ENTERO\nINICIO\n    pares <- 0\n    impares <- 0\n    PARA i DE 1 A 10 HACER\n        SI numeros[i] MOD 2 = 0 ENTONCES\n            pares <- pares + 1\n        SINO\n            impares <- impares + 1\n        FIN_SI\n    FIN_PARA\n    ESCRIBIR \"Pares: \", pares\n    ESCRIBIR \"Impares: \", impares\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\nnumeros = [12, 7, 5, 18, 3, 22, 9, 14, 6, 11]  # Ejemplo\npares = 0\nimpares = 0\n\nfor i in range(10):\n    if numeros[i] % 2 == 0:\n        pares = pares + 1\n    else:\n        impares = impares + 1\n\nprint(\"Pares:\", pares)\nprint(\"Impares:\", impares)\n\nDiferencias sintácticas:\n1. 'MOD' se representa con '%' en Python para operación módulo.\n2. Igualdad se verifica con '==' no con '=' (que es asignación).\n3. Python permite incremento abreviado: 'pares += 1' en lugar de 'pares = pares + 1'.\n4. Alternativa pythónica: 'for num in numeros:' itera directamente sobre valores sin índices.\n5. Ejemplo pythónico completo: pares = sum(1 for n in numeros if n % 2 == 0)"
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO MCDEuclidesRecursivo\nFUNCIÓN MCD(a, b : ENTERO) : ENTERO\nINICIO\n    SI b = 0 ENTONCES\n        RETORNAR a\n    SINO\n        RETORNAR MCD(b, a MOD b)\n    FIN_SI\nFIN_FUNCIÓN\n\nINICIO_PROGRAMA\n    VARIABLES\n        num1, num2, resultado : ENTERO\n    LEER num1, num2\n    resultado <- MCD(num1, num2)\n    ESCRIBIR \"El MCD es: \", resultado\nFIN_PROGRAMA",
    "output": "Claro viejito, # Código Python equivalente:\ndef mcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return mcd(b, a % b)\n\n# Programa principal\nnum1 = int(input(\"Ingrese primer número: \"))\nnum2 = int(input(\"Ingrese segundo número: \"))\nresultado = mcd(num1, num2)\nprint(\"El MCD es:\", resultado)\n\nDiferencias sintácticas:\n1. Función recursiva: Python maneja la recursión igual que el pseudocódigo, llamándose a sí misma.\n2. El caso base 'SI b = 0' detiene la recursión y comienza el retorno.\n3. 'a MOD b' se escribe como 'a % b' en Python.\n4. No existe separación INICIO_PROGRAMA, el código de nivel superior se ejecuta directamente.\n5. Esta es la versión recursiva del algoritmo de Euclides (más elegante que la iterativa).\n6. Python permite versión de una línea: 'return a if b == 0 else mcd(b, a % b)'."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO SumaPares\nVARIABLES\n    suma : ENTERO\n    i : ENTERO\nINICIO\n    suma <- 0\n    PARA i DE 1 A 10 HACER\n        SI i MOD 2 = 0 ENTONCES\n            suma <- suma + i\n        FIN_SI\n    FIN_PARA\n    ESCRIBIR suma\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\nsuma = 0\nfor i in range(1, 11):\n    if i % 2 == 0:\n        suma += i\nprint(suma)\n\nNotas: 'MOD' es '%', el rango en Python termina en 10 con range(1, 11), y la indentación reemplaza los FIN_PARA/FIN_SI."
  },
  {
    "instruction": "Convierte este pseudocódigo a Python y explícalo.",
    "input": "ALGORITMO ConteoRegresivo\nVARIABLES\n    n : ENTERO\nINICIO\n    LEER n\n    MIENTRAS n > 0 HACER\n        ESCRIBIR n\n        n <- n - 1\n    FIN_MIENTRAS\n    ESCRIBIR Despegue\nFIN",
    "output": "Claro viejito, # Código Python equivalente:\nn = int(input('Ingresa n: '))\nwhile n > 0:\n    print(n)\n    n -= 1\nprint('Despegue')\n\nDiferencias: 'MIENTRAS' es 'while', el decremento es 'n -= 1', y las comillas dobles en pseudocódigo se escriben como string normal en Python."
  }
]